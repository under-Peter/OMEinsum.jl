<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DocStrings · OMEinsum.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OMEinsum.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../parsing/">Parsing</a></li><li><a class="tocitem" href="../implementation/">Implementations</a></li><li><a class="tocitem" href="../extending/">Extending OMEinsum</a></li><li class="is-active"><a class="tocitem" href>DocStrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DocStrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DocStrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/docstrings.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.EinArray" href="#OMEinsum.EinArray"><code>OMEinsum.EinArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinArray{T, N, TT, LX, LY, ICT, OCT} &lt;: AbstractArray{T, N}</code></pre><p>A struct to hold the intermediate result of an <code>einsum</code> where all index-labels of both input and output are expanded to a rank-<code>N</code>-array whose values are lazily calculated. Indices are arranged as <em>inner indices</em> (or reduced dimensions) first and <em>then outer indices</em>.</p><p>Type parameters are</p><pre><code class="nohighlight hljs">* `T`: element type,
* `N`: array dimension,
* `TT`: type of &quot;tuple of input arrays&quot;,
* `LX`: type of &quot;tuple of input indexers&quot;,
* `LX`: type of output indexer,
* `ICT`: typeof inner CartesianIndices,
* `OCT`: typeof outer CartesianIndices,</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL57-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.EinCode" href="#OMEinsum.EinCode"><code>OMEinsum.EinCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinCode{ixs, iy}</code></pre><p>Wrapper to <code>eincode</code>-specification that creates a callable object to evaluate the <code>eincode</code> <code>ixs -&gt; iy</code> where <code>ixs</code> are the index-labels of the input-tensors and <code>iy</code> are the index-labels of the output</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;))(a, b) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL4-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.EinIndexer" href="#OMEinsum.EinIndexer"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs,N}</code></pre><p>A structure for indexing <code>EinArray</code>s. <code>locs</code> is the index positions (among all indices). In the constructor, <code>size</code> is the size of target tensor,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{locs}, Tuple{N}} where {N, locs}" href="#OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{locs}, Tuple{N}} where {N, locs}"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs}(size::Tuple)</code></pre><p>Constructor for <code>EinIndexer</code> for an object of size <code>size</code> where <code>locs</code> are the locations of relevant indices in a larger tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.IndexGroup" href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexGroup</code></pre><p>Leaf in a contractiontree, contains the indices and the number of the tensor it describes, e.g. in &quot;ij,jk -&gt; ik&quot;, indices &quot;ik&quot; belong to tensor <code>1</code>, so would be described by IndexGroup([&#39;i&#39;,&#39;k&#39;], 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/einsequence.jl#LL90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.NestedEinsumConstructor" href="#OMEinsum.NestedEinsumConstructor"><code>OMEinsum.NestedEinsumConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedEinsumConstructor</code></pre><p>describes a (potentially) nested einsum. Important fields:</p><ul><li><code>args</code>, vector of all inputs, either <code>IndexGroup</code> objects corresponding to tensors or <code>NestedEinsumConstructor</code></li><li><code>iy</code>, indices of output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/einsequence.jl#LL105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{EinArray{T, N, TT, LX, LY, ICT, OCT} where {N, TT, LX, LY, ICT, OCT}, Any}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{EinArray{T, N, TT, LX, LY, ICT, OCT} where {N, TT, LX, LY, ICT, OCT}, Any}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A::EinArray, inds...)</code></pre><p>return the lazily calculated entry of <code>A</code> at index <code>inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.ContractionOrder.timespace_complexity-Tuple{Int64, Any}" href="#OMEinsum.ContractionOrder.timespace_complexity-Tuple{Int64, Any}"><code>OMEinsum.ContractionOrder.timespace_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ContractionOrder.timespace_complexity(eincode, size_dict)</code></pre><p>Return the time and space complexity of the einsum contraction. The time complexity is defined as <code>log2(number of element multiplication)</code>. The space complexity is defined as <code>log2(size of the maximum intermediate tensor)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/contractionorder/contractionorder.jl#LL92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.allow_loops-Tuple{Bool}" href="#OMEinsum.allow_loops-Tuple{Bool}"><code>OMEinsum.allow_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allow_loops(flag::Bool)</code></pre><p>Setting this to <code>false</code> will cause OMEinsum to log an error if it falls back to <code>loop_einsum</code> evaluation, instead of calling specialised kernels. The default is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/loop_einsum.jl#LL54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.allunique-Tuple{Any}" href="#OMEinsum.allunique-Tuple{Any}"><code>OMEinsum.allunique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allunique(ix::Tuple)</code></pre><p>return true if all elements of <code>ix</code> appear only once in <code>ix</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: allunique

julia&gt; allunique((1,2,3,4))
true

julia&gt; allunique((1,2,3,1))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/utils.jl#LL45-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T" href="#OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T"><code>OMEinsum.analyze_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the expected labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/binaryrules.jl#LL270-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.asarray-Tuple{Any}" href="#OMEinsum.asarray-Tuple{Any}"><code>OMEinsum.asarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asarray(x[, parent::AbstractArray]) -&gt; AbstactArray</code></pre><p>Return a 0-dimensional array with item <code>x</code>, otherwise, do nothing. If a <code>parent</code> is supplied, it will try to match the parent array type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/utils.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:Tuple{Vararg{AbstractArray, NI}}}" href="#OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:Tuple{Vararg{AbstractArray, NI}}}"><code>OMEinsum.einarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einarray(::EinCode, xs, size_dict) -&gt; EinArray</code></pre><p>Constructor of <code>EinArray</code> from an <code>EinCode</code>, a tuple of tensors <code>xs</code> and a <code>size_dict</code> that assigns each index-label a size. The returned <code>EinArray</code> holds an intermediate result of the <code>einsum</code> specified by the <code>EinCode</code> with indices corresponding to all unique labels in the einsum. Reduction over the (lazily calculated) dimensions that correspond to labels not present in the output lead to the result of the einsum.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a, b));

julia&gt; ea = OMEinsum.einarray(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a,b), sd);

julia&gt; dropdims(sum(ea, dims=1), dims=1) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL87-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.einsum-Union{Tuple{LT}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, Any, Dict{LT, V} where V}} where {ixs, iy, LT}" href="#OMEinsum.einsum-Union{Tuple{LT}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, Any, Dict{LT, V} where V}} where {ixs, iy, LT}"><code>OMEinsum.einsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einsum(::EinCode{ixs, iy}, xs, size_dict) where {ixs, iy}</code></pre><p>return the tensor that results from contracting the tensors <code>xs</code> according to their indices <code>ixs</code>, where all indices that do not appear in the output <code>iy</code> are summed over. The result is permuted according to <code>out</code>.</p><ul><li><p><code>ixs</code> - tuple of tuples of index-labels of the input-tensors <code>xs</code></p></li><li><p><code>iy</code> - tuple of index-labels of the output-tensor</p></li><li><p><code>xs</code> - tuple of tensors</p></li><li><p><code>size_dict</code> - a dictionary that maps index-labels to their sizes</p></li></ul><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a, b)) ≈ a * b
true

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;k&#39;,&#39;i&#39;)), (a, b)) ≈ permutedims(a * b, (2,1))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/interfaces.jl#LL134-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.einsum_grad-NTuple{6, Any}" href="#OMEinsum.einsum_grad-NTuple{6, Any}"><code>OMEinsum.einsum_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einsum_grad(ixs, xs, iy, size_dict, cdy, i)</code></pre><p>return the gradient of the result of evaluating the <code>EinCode</code> w.r.t the <code>i</code>th tensor in <code>xs</code>. <code>cdy</code> is the result of applying the <code>EinCode</code> to the <code>xs</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: einsum_grad, get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; c = einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (&#39;i&#39;,&#39;k&#39;)), (a,b));

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b));

julia&gt; einsum_grad(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b), (&#39;i&#39;,&#39;k&#39;), sd, c, 1) ≈ c * transpose(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/autodiff.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.filliys!-Tuple{Any}" href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filliys!(neinsum::NestedEinsumConstructor)</code></pre><p>goes through all <code>NestedEinsumConstructor</code> objects in the tree and saves the correct <code>iy</code> in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/einsequence.jl#LL69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.get_size_dict" href="#OMEinsum.get_size_dict"><code>OMEinsum.get_size_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_size_dict(ixs, xs, size_info=nothing)</code></pre><p>return a dictionary that is used to get the size of an index-label in the einsum-specification with input-indices <code>ixs</code> and tensors <code>xs</code> after consistency within <code>ixs</code> and between <code>ixs</code> and <code>xs</code> has been verified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/interfaces.jl#LL45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.indices_and_locs-Tuple{Any, Any}" href="#OMEinsum.indices_and_locs-Tuple{Any, Any}"><code>OMEinsum.indices_and_locs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indices_and_locs(ixs,iy)</code></pre><p>given the index-labels of input and output of an <code>einsum</code>, return (in the same order):</p><ul><li>a tuple of the distinct index-labels of the output <code>iy</code></li><li>a tuple of the distinct index-labels in <code>ixs</code> of the input not appearing in the output <code>iy</code></li><li>a tuple of tuples of locations of an index-label in the <code>ixs</code> in a list of all index-labels</li><li>a tuple of locations of index-labels in <code>iy</code> in a list of all index-labels</li></ul><p>where the list of all index-labels is simply the first  and the second output catenated and the second output catenated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL155-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.loop_einsum!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs, iy}, Tuple{Vararg{AbstractArray{var&quot;#s4&quot;, M} where {M, var&quot;#s4&quot;}, N}}, AbstractArray{T, L}, Any}} where {N, L, T, IT&lt;:Union{AbstractChar, Integer}, ixs, iy}" href="#OMEinsum.loop_einsum!-Union{Tuple{iy}, Tuple{ixs}, Tuple{IT}, Tuple{T}, Tuple{L}, Tuple{N}, Tuple{EinCode{ixs, iy}, Tuple{Vararg{AbstractArray{var&quot;#s4&quot;, M} where {M, var&quot;#s4&quot;}, N}}, AbstractArray{T, L}, Any}} where {N, L, T, IT&lt;:Union{AbstractChar, Integer}, ixs, iy}"><code>OMEinsum.loop_einsum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_einsum!(::EinCode, xs, y, size_dict)</code></pre><p>inplace-version of <code>loop_einsum</code>, saving the result in a preallocated tensor of correct size <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/loop_einsum.jl#LL17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.loop_einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{N}, Tuple{EinCode{ixs, iy}, Tuple{Vararg{AbstractArray{var&quot;#s4&quot;, M} where {M, var&quot;#s4&quot;}, N}}, Any}} where {N, ixs, iy}" href="#OMEinsum.loop_einsum-Union{Tuple{iy}, Tuple{ixs}, Tuple{N}, Tuple{EinCode{ixs, iy}, Tuple{Vararg{AbstractArray{var&quot;#s4&quot;, M} where {M, var&quot;#s4&quot;}, N}}, Any}} where {N, ixs, iy}"><code>OMEinsum.loop_einsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_einsum(::EinCode, xs, size_dict)</code></pre><p>evaluates the eincode specified by <code>EinCode</code> and the tensors <code>xs</code> by looping over all possible indices and calculating the contributions ot the result. Scales exponentially in the number of distinct index-labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/loop_einsum.jl#LL4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, Tuple{Vararg{Any, N}}}} where N" href="#OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, Tuple{Vararg{Any, N}}}} where N"><code>OMEinsum.map_prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_prod(xs, ind, indexers)</code></pre><p>calculate the value of an <code>EinArray</code> with <code>EinIndexer</code>s <code>indexers</code> at location <code>ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/Core.jl#LL145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Tuple{Vararg{Tuple{Vararg{T, N}} where {N, T}, Nx}} where Nx, Tuple}" href="#OMEinsum.match_rule-Tuple{Tuple{Vararg{Tuple{Vararg{T, N}} where {N, T}, Nx}} where Nx, Tuple}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match_rule(ixs, iy)
match_rule(code::EinCode{ixs, iy})
match_rule(code::NestedEinCode)</code></pre><p>Returns the rule that matches, otherwise use <code>DefaultRule</code> - the slow <code>loop_einsum</code> backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/unaryrules.jl#LL19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.nopermute-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}" href="#OMEinsum.nopermute-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}"><code>OMEinsum.nopermute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nopermute(ix,iy)</code></pre><p>check that all values in <code>iy</code> that are also in <code>ix</code> have the same relative order,</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: nopermute

julia&gt; nopermute((1,2,3),(1,2))
true

julia&gt; nopermute((1,2,3),(2,1))
false</code></pre><p>e.g. <code>nopermute((1,2,3),(1,2))</code> is true while <code>nopermute((1,2,3),(2,1))</code> is false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/utils.jl#LL16-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.optimize_greedy-Union{Tuple{T}, Tuple{L}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, Dict{L, T}}} where {ixs, iy, L, T}" href="#OMEinsum.optimize_greedy-Union{Tuple{T}, Tuple{L}, Tuple{iy}, Tuple{ixs}, Tuple{EinCode{ixs, iy}, Dict{L, T}}} where {ixs, iy, L, T}"><code>OMEinsum.optimize_greedy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_greedy(eincode, size_dict; method=MinSpaceOut(), nrepeat=10)</code></pre><p>Greedy optimizing the contraction order and return a <code>NestedEinsum</code> object. Methods are</p><ul><li><code>MinSpaceOut</code>, always choose the next contraction that produces the minimum output tensor.</li><li><code>MinSpaceDiff</code>, always choose the next contraction that minimizes the total space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/contractionorder/contractionorder.jl#LL52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}" href="#OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}"><code>OMEinsum.parse_parens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_parens(s::AbstractString, i, narg)</code></pre><p>parse one level of parens starting at index <code>i</code> where <code>narg</code> counts which tensor the current group of indices, e.g. &quot;ijk&quot;, belongs to. Recursively calls itself for each new opening paren that&#39;s opened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/einsequence.jl#LL21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.tensorpermute-Tuple{AbstractArray, Any}" href="#OMEinsum.tensorpermute-Tuple{AbstractArray, Any}"><code>OMEinsum.tensorpermute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensorpermute(A, perm)</code></pre><p>Aliasing <code>permutedims(A, perm)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/utils.jl#LL75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.@ein-Tuple" href="#OMEinsum.@ein-Tuple"><code>OMEinsum.@ein</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ein A[i,k] := B[i,j] * C[j,k]     # A = B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>You may use numbers in place of letters for dummy indices, as in <code>@tensor</code>, and need not name the output array. Thus <code>A = @ein [1,2] := B[1,ξ] * C[ξ,2]</code> is equivalent to the above. This can also be written <code>A = ein&quot;ij,jk -&gt; ik&quot;(B,C)</code> using the numpy-style string macro.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; @ein c[i,k] := a[i,j] * b[j,k];

julia&gt; c ≈ a * b
true

julia&gt; c ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/interfaces.jl#LL75-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OMEinsum.@ein_str-Tuple{AbstractString}" href="#OMEinsum.@ein_str-Tuple{AbstractString}"><code>OMEinsum.@ein_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">ein&quot;ij,jk -&gt; ik&quot;(A,B)</code></pre><p>String macro interface which understands <code>numpy.einsum</code>&#39;s notation. Translates strings into <code>EinCode</code>-structs that can be called to evaluate an <code>einsum</code>. To control evaluation order, use parentheses - instead of an <code>EinCode</code>, a <code>NestedEinsum</code> is returned which evaluates the expression according to parens. The valid character ranges for index-labels are <code>a-z</code> and <code>α-ω</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c = rand(10,10), rand(10,10), rand(10,1);

julia&gt; ein&quot;ij,jk,kl -&gt; il&quot;(a,b,c) ≈ ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c) ≈ a * b * c
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/ff15d54a51dce1ef5349c437b5aaff9c8e145df1/src/interfaces.jl#LL2-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../extending/">« Extending OMEinsum</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 4 August 2021 22:40">Wednesday 4 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
