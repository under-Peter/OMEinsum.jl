<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · OMEinsum.jl</title><meta name="title" content="Manual · OMEinsum.jl"/><meta property="og:title" content="Manual · OMEinsum.jl"/><meta property="twitter:title" content="Manual · OMEinsum.jl"/><meta name="description" content="Documentation for OMEinsum.jl."/><meta property="og:description" content="Documentation for OMEinsum.jl."/><meta property="twitter:description" content="Documentation for OMEinsum.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OMEinsum.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../background/">Background: Tensor Networks</a></li><li><a class="tocitem" href="../basic/">Basic usage</a></li><li><a class="tocitem" href="../contractionorder/">Contraction order optimization</a></li><li><a class="tocitem" href="../autodiff/">Automatic differentiation</a></li><li><a class="tocitem" href="../cuda/">CUDA</a></li><li><a class="tocitem" href="../applications/">Applications</a></li><li class="is-active"><a class="tocitem" href>Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/docstrings.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.DynamicEinCode" href="#OMEinsum.DynamicEinCode"><code>OMEinsum.DynamicEinCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DynamicEinCode{LT}
DynamicEinCode(ixs, iy)</code></pre><p>Wrapper to <code>eincode</code>-specification that creates a callable object to evaluate the <code>eincode</code> <code>ixs -&gt; iy</code> where <code>ixs</code> are the index-labels of the input-tensors and <code>iy</code> are the index-labels of the output.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; OMEinsum.DynamicEinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;))(a, b) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL65-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.DynamicNestedEinsum" href="#OMEinsum.DynamicNestedEinsum"><code>OMEinsum.DynamicNestedEinsum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DynamicNestedEinsum{LT} &lt;: NestedEinsum{LT}
DynamicNestedEinsum(args, eins)
DynamicNestedEinsum{LT}(tensorindex::Int)</code></pre><p>Einsum with contraction order, where the type parameter <code>LT</code> is the label type. It has two constructors. One takes a <code>tensorindex</code> as input, which represents the leaf node in a contraction tree. The other takes an iterable of type <code>DynamicNestedEinsum</code>, <code>args</code>, as the siblings, and <code>eins</code> to specify the contraction operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL163-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinArray" href="#OMEinsum.EinArray"><code>OMEinsum.EinArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EinArray{T, N, TT, LX, LY, ICT, OCT} &lt;: AbstractArray{T, N}</code></pre><p>A struct to hold the intermediate result of an <code>einsum</code> where all index-labels of both input and output are expanded to a rank-<code>N</code>-array whose values are lazily calculated. Indices are arranged as <em>inner indices</em> (or reduced dimensions) first and <em>then outer indices</em>.</p><p>Type parameters are</p><pre><code class="nohighlight hljs">* `T`: element type,
* `N`: array dimension,
* `TT`: type of &quot;tuple of input arrays&quot;,
* `LX`: type of &quot;tuple of input indexers&quot;,
* `LX`: type of output indexer,
* `ICT`: typeof inner CartesianIndices,
* `OCT`: typeof outer CartesianIndices,</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL147-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinCode" href="#OMEinsum.EinCode"><code>OMEinsum.EinCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EinCode &lt;: AbstractEinsum
EinCode(ixs, iy)</code></pre><p>Abstract type for sum-product contraction code. The constructor returns a <code>DynamicEinCode</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinIndexer" href="#OMEinsum.EinIndexer"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs,N}</code></pre><p>A structure for indexing <code>EinArray</code>s. <code>locs</code> is the index positions (among all indices). In the constructor, <code>size</code> is the size of target tensor,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinIndexer-Union{Tuple{NTuple{N, Int64}}, Tuple{locs}, Tuple{N}} where {N, locs}" href="#OMEinsum.EinIndexer-Union{Tuple{NTuple{N, Int64}}, Tuple{locs}, Tuple{N}} where {N, locs}"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs}(size::Tuple)</code></pre><p>Constructor for <code>EinIndexer</code> for an object of size <code>size</code> where <code>locs</code> are the locations of relevant indices in a larger tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.IndexGroup" href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IndexGroup</code></pre><p>Leaf in a contractiontree, contains the indices and the number of the tensor it describes, e.g. in &quot;ij,jk -&gt; ik&quot;, indices &quot;ik&quot; belong to tensor <code>1</code>, so would be described by IndexGroup([&#39;i&#39;,&#39;k&#39;], 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.NestedEinsum" href="#OMEinsum.NestedEinsum"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NestedEinsum{LT} &lt;: AbstractEinsum</code></pre><p>The abstract type for contraction trees. It has two subtypes, <a href="#OMEinsum.DynamicNestedEinsum"><code>DynamicNestedEinsum</code></a> and <a href="#OMEinsum.StaticNestedEinsum"><code>StaticNestedEinsum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.NestedEinsumConstructor" href="#OMEinsum.NestedEinsumConstructor"><code>OMEinsum.NestedEinsumConstructor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NestedEinsumConstructor</code></pre><p>describes a (potentially) nested einsum. Important fields:</p><ul><li><code>args</code>, vector of all inputs, either <code>IndexGroup</code> objects corresponding to tensors or <code>NestedEinsumConstructor</code></li><li><code>iy</code>, indices of output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.SlicedEinsum" href="#OMEinsum.SlicedEinsum"><code>OMEinsum.SlicedEinsum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SlicedEinsum{LT, Ein} &lt;: AbstractEinsum</code></pre><p>A tensor network with slicing. <code>LT</code> is the label type and <code>Ein</code> is the tensor network.</p><p><strong>Fields</strong></p><ul><li><code>slicing::Vector{LT}</code>: A vector of labels to slice.</li><li><code>eins::Ein</code>: The tensor network.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/slicing.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.StaticEinCode" href="#OMEinsum.StaticEinCode"><code>OMEinsum.StaticEinCode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticEinCode{LT, ixs, iy}</code></pre><p>The static version of <code>DynamicEinCode</code> that matches the contraction rule at compile time. It is the default return type of <code>@ein_str</code> macro. <code>LT</code> is the label type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.StaticNestedEinsum" href="#OMEinsum.StaticNestedEinsum"><code>OMEinsum.StaticNestedEinsum</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StaticNestedEinsum{LT,args,eins} &lt;: NestedEinsum{LT}
StaticNestedEinsum(args, eins)
StaticNestedEinsum{LT}(tensorindex::Int)</code></pre><p>Einsum with contraction order, where the type parameter <code>LT</code> is the label type, <code>args</code> is a tuple of StaticNestedEinsum, <code>eins</code> is a <code>StaticEinCode</code> and leaf node is defined by setting <code>eins</code> to an integer. It has two constructors. One takes a <code>tensorindex</code> as input, which represents the leaf node in a contraction tree. The other takes an iterable of type <code>DynamicNestedEinsum</code>, <code>args</code>, as the siblings, and <code>eins</code> to specify the contraction operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL191-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{EinArray{T}, Any}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{EinArray{T}, Any}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getindex(A::EinArray, inds...)</code></pre><p>return the lazily calculated entry of <code>A</code> at index <code>inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.allow_loops-Tuple{Bool}" href="#OMEinsum.allow_loops-Tuple{Bool}"><code>OMEinsum.allow_loops</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allow_loops(flag::Bool)</code></pre><p>Setting this to <code>false</code> will cause OMEinsum to log an error if it falls back to <code>loop_einsum</code> evaluation, instead of calling specialised kernels. The default is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/loop_einsum.jl#LL65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.allunique-Tuple{Any}" href="#OMEinsum.allunique-Tuple{Any}"><code>OMEinsum.allunique</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allunique(ix::Tuple)</code></pre><p>return true if all elements of <code>ix</code> appear only once in <code>ix</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: allunique

julia&gt; allunique((1,2,3,4))
true

julia&gt; allunique((1,2,3,1))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/utils.jl#LL87-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T" href="#OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T"><code>OMEinsum.analyze_binary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the expected labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsum.jl#LL136-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.asarray-Tuple{Any}" href="#OMEinsum.asarray-Tuple{Any}"><code>OMEinsum.asarray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">asarray(x[, parent::AbstractArray]) -&gt; AbstactArray</code></pre><p>Return a 0-dimensional array with item <code>x</code>, otherwise, do nothing. If a <code>parent</code> is supplied, it will try to match the parent array type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/utils.jl#LL39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.back_propagate-Union{Tuple{T}, Tuple{Any, SlicedEinsum, OMEinsum.CacheTree{T}, AbstractArray{T}, Dict}} where T" href="#OMEinsum.back_propagate-Union{Tuple{T}, Tuple{Any, SlicedEinsum, OMEinsum.CacheTree{T}, AbstractArray{T}, Dict}} where T"><code>OMEinsum.back_propagate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">back_propagate(f, code, cache, ȳ, size_dict)</code></pre><p>Back propagate the message <code>ȳ</code> through the cached tree <code>cache</code> and return a tree storing the intermediate messages. The message can be gradients et al.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The back-propagation rule. The signature is <code>f(eins, xs, y, size_dict, dy) -&gt; dxs</code>, where<ul><li><code>eins</code>: The contraction code at the current node.</li><li><code>xs</code>: The input tensors at the current node.</li><li><code>y</code>: The output tensor at the current node.</li><li><code>size_dict</code>: The size dictionary, which maps the label to the size of the corresponding dimension.</li><li><code>dy</code>: The message on the output tensor (<code>y</code>) to back-propagate through the current node.</li><li><code>dxs</code>: The message on the input tensors (<code>xs</code>) as the result of back-propagation.</li></ul></li><li><code>code</code>: The contraction code, which can be a <code>NestedEinsum</code> or a <code>SlicedEinsum</code>.</li><li><code>cache</code>: The cached intermediate results, which can be generated by <a href="#OMEinsum.cached_einsum-Tuple{SlicedEinsum, Any, Any}"><code>cached_einsum</code></a>.</li><li><code>ȳ</code>: The message to back-propagate.</li><li><code>size_dict</code>: The size dictionary, which maps the label to the size of the corresponding dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>CacheTree</code>: The tree storing the intermediate messages.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/bp.jl#LL50-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.cached_einsum-Tuple{SlicedEinsum, Any, Any}" href="#OMEinsum.cached_einsum-Tuple{SlicedEinsum, Any, Any}"><code>OMEinsum.cached_einsum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cached_einsum(code, xs, size_dict)</code></pre><p>Compute the einsum contraction and cache the intermediate contraction results.</p><p><strong>Arguments</strong></p><ul><li><code>code</code>: The contraction code, which can be a <code>NestedEinsum</code> or a <code>SlicedEinsum</code>.</li><li><code>xs</code>: The input tensors.</li><li><code>size_dict</code>: The size dictionary, which maps the label to the size of the corresponding dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>CacheTree</code>: The cached tree storing the intermediate results.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/bp.jl#LL11-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.cost_and_gradient" href="#OMEinsum.cost_and_gradient"><code>OMEinsum.cost_and_gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cost_and_gradient(code, xs, ȳ)</code></pre><p>Compute the cost and the gradients w.r.t the input tensors <code>xs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>code</code>: The contraction code, which can be a <code>NestedEinsum</code> or a <code>SlicedEinsum</code>.</li><li><code>xs</code>: The input tensors.</li><li><code>ȳ</code>: The message to back-propagate. Default is <code>1</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>cost</code>: The cost of the contraction.</li><li><code>grads</code>: The gradients w.r.t the input tensors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/bp.jl#LL108-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{Val{ixs}, Val{iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:NTuple{NI, AbstractArray}}" href="#OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{Val{ixs}, Val{iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:NTuple{NI, AbstractArray}}"><code>OMEinsum.einarray</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">einarray(::Val{ixs}, Val{iy}, xs, size_dict) -&gt; EinArray</code></pre><p>Constructor of <code>EinArray</code> from an <code>EinCode</code>, a tuple of tensors <code>xs</code> and a <code>size_dict</code> that assigns each index-label a size. The returned <code>EinArray</code> holds an intermediate result of the <code>einsum</code> specified by the <code>EinCode</code> with indices corresponding to all unique labels in the einsum. Reduction over the (lazily calculated) dimensions that correspond to labels not present in the output lead to the result of the einsum.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a, b));

julia&gt; ea = OMEinsum.einarray(Val(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;))),Val((&#39;i&#39;,&#39;k&#39;)), (a,b), sd);

julia&gt; dropdims(sum(ea, dims=1), dims=1) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL177-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einsum" href="#OMEinsum.einsum"><code>OMEinsum.einsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">einsum(code::EinCode, xs, size_dict)</code></pre><p>Return the tensor that results from contracting the tensors <code>xs</code> according to the contraction code <code>code</code>.</p><p><strong>Arguments</strong></p><ul><li><code>code</code>: The einsum notation, which can be an instance of <a href="#OMEinsum.EinCode"><code>EinCode</code></a>, <a href="#OMEinsum.NestedEinsum"><code>NestedEinsum</code></a>, or <a href="#OMEinsum.SlicedEinsum"><code>SlicedEinsum</code></a>.</li><li><code>xs</code> - the input tensors</li><li><code>size_dict</code> - a dictionary that maps index-labels to their sizes</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a, b)) ≈ a * b
true

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;k&#39;,&#39;i&#39;)), (a, b)) ≈ permutedims(a * b, (2,1))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsum.jl#LL2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einsum!" href="#OMEinsum.einsum!"><code>OMEinsum.einsum!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">einsum!(code::EinCode, xs, y, sx, sy, size_dict)</code></pre><p>Inplace version of <code>einsum</code>. The result is stored in <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><code>code</code>: The einsum notation, which can be an instance of <a href="#OMEinsum.EinCode"><code>EinCode</code></a>, <a href="#OMEinsum.NestedEinsum"><code>NestedEinsum</code></a>, or <a href="#OMEinsum.SlicedEinsum"><code>SlicedEinsum</code></a>.</li><li><code>xs</code>: The input tensors.</li><li><code>y</code>: The output tensor.</li><li><code>sx</code>: Scale <code>x</code> by <code>sx</code>.</li><li><code>sy</code>: Scale <code>y</code> by <code>sy</code>.</li><li><code>size_dict</code>: A dictionary that maps index-labels to their sizes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsum.jl#LL30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einsum_grad-NTuple{6, Any}" href="#OMEinsum.einsum_grad-NTuple{6, Any}"><code>OMEinsum.einsum_grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">einsum_grad(ixs, xs, iy, size_dict, cdy, i)</code></pre><p>return the gradient of the result of evaluating the <code>EinCode</code> w.r.t the <code>i</code>th tensor in <code>xs</code>. <code>cdy</code> is the result of applying the <code>EinCode</code> to the <code>xs</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: einsum_grad, get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; c = einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (&#39;i&#39;,&#39;k&#39;)), (a,b));

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b));

julia&gt; einsum_grad(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b), (&#39;i&#39;,&#39;k&#39;), sd, c, 1) ≈ c * transpose(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/autodiff.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.filliys!-Tuple{Any}" href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">filliys!(neinsum::NestedEinsumConstructor)</code></pre><p>goes through all <code>NestedEinsumConstructor</code> objects in the tree and saves the correct <code>iy</code> in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.get_size_dict!-Union{Tuple{LT}, Tuple{Any, Any, Dict{LT}}} where LT" href="#OMEinsum.get_size_dict!-Union{Tuple{LT}, Tuple{Any, Any, Dict{LT}}} where LT"><code>OMEinsum.get_size_dict!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_size_dict!(ixs, xs, size_info)</code></pre><p>return a dictionary that is used to get the size of an index-label in the einsum-specification with input-indices <code>ixs</code> and tensors <code>xs</code> after consistency within <code>ixs</code> and between <code>ixs</code> and <code>xs</code> has been verified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/interfaces.jl#LL60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.getixsv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT" href="#OMEinsum.getixsv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT"><code>OMEinsum.getixsv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getixsv(code)</code></pre><p>Get labels of input tensors for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector of vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; getixsv(ein&quot;(ij,jk),k-&gt;i&quot;)
3-element Vector{Vector{Char}}:
 [&#39;i&#39;, &#39;j&#39;]
 [&#39;j&#39;, &#39;k&#39;]
 [&#39;k&#39;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL33-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.getiyv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT" href="#OMEinsum.getiyv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT"><code>OMEinsum.getiyv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getiy(code)</code></pre><p>Get labels of the output tensor for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector.</p><pre><code class="language-julia-repl hljs">julia&gt; getiyv(ein&quot;(ij,jk),k-&gt;i&quot;)
1-element Vector{Char}:
 &#39;i&#39;: ASCII/Unicode U+0069 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.indices_and_locs-Tuple{Any, Any}" href="#OMEinsum.indices_and_locs-Tuple{Any, Any}"><code>OMEinsum.indices_and_locs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">indices_and_locs(ixs,iy)</code></pre><p>given the index-labels of input and output of an <code>einsum</code>, return (in the same order):</p><ul><li>a tuple of the distinct index-labels of the output <code>iy</code></li><li>a tuple of the distinct index-labels in <code>ixs</code> of the input not appearing in the output <code>iy</code></li><li>a tuple of tuples of locations of an index-label in the <code>ixs</code> in a list of all index-labels</li><li>a tuple of locations of index-labels in <code>iy</code> in a list of all index-labels</li></ul><p>where the list of all index-labels is simply the first  and the second output catenated and the second output catenated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL245-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.loop_einsum!-Union{Tuple{T}, Tuple{L}, Tuple{N}, Tuple{Any, Any, NTuple{N, AbstractArray}, AbstractArray{T, L}, Any, Any, Any}} where {N, L, T}" href="#OMEinsum.loop_einsum!-Union{Tuple{T}, Tuple{L}, Tuple{N}, Tuple{Any, Any, NTuple{N, AbstractArray}, AbstractArray{T, L}, Any, Any, Any}} where {N, L, T}"><code>OMEinsum.loop_einsum!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_einsum!(ixs, iy, xs, y, sx, sy, size_dict)</code></pre><p>inplace-version of <code>loop_einsum</code>, saving the result in a preallocated tensor of correct size <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/loop_einsum.jl#LL15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.loop_einsum-Union{Tuple{N}, Tuple{EinCode, NTuple{N, AbstractArray}, Any}} where N" href="#OMEinsum.loop_einsum-Union{Tuple{N}, Tuple{EinCode, NTuple{N, AbstractArray}, Any}} where N"><code>OMEinsum.loop_einsum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loop_einsum(::EinCode, xs, size_dict)</code></pre><p>evaluates the eincode specified by <code>EinCode</code> and the tensors <code>xs</code> by looping over all possible indices and calculating the contributions ot the result. Scales exponentially in the number of distinct index-labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/loop_einsum.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, NTuple{N, Any}}} where N" href="#OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, NTuple{N, Any}}} where N"><code>OMEinsum.map_prod</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">map_prod(xs, ind, indexers)</code></pre><p>calculate the value of an <code>EinArray</code> with <code>EinIndexer</code>s <code>indexers</code> at location <code>ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/Core.jl#LL235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Any, Any}" href="#OMEinsum.match_rule-Tuple{Any, Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">match_rule(ixs, iy)
match_rule(code::EinCode)</code></pre><p>Returns the rule that matches, otherwise use <code>DefaultRule</code> - the slow <code>loop_einsum</code> backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/matchrule.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.nopermute-Tuple{NTuple{N, T} where {N, T}, NTuple{N, T} where {N, T}}" href="#OMEinsum.nopermute-Tuple{NTuple{N, T} where {N, T}, NTuple{N, T} where {N, T}}"><code>OMEinsum.nopermute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nopermute(ix,iy)</code></pre><p>check that all values in <code>iy</code> that are also in <code>ix</code> have the same relative order,</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: nopermute

julia&gt; nopermute((1,2,3),(1,2))
true

julia&gt; nopermute((1,2,3),(2,1))
false</code></pre><p>e.g. <code>nopermute((1,2,3),(1,2))</code> is true while <code>nopermute((1,2,3),(2,1))</code> is false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/utils.jl#LL58-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}" href="#OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}"><code>OMEinsum.parse_parens</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse_parens(s::AbstractString, i, narg)</code></pre><p>parse one level of parens starting at index <code>i</code> where <code>narg</code> counts which tensor the current group of indices, e.g. &quot;ijk&quot;, belongs to. Recursively calls itself for each new opening paren that&#39;s opened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/einsequence.jl#LL19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.tensorpermute!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Any, Any, Any}} where {T, N}" href="#OMEinsum.tensorpermute!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Any, Any, Any}} where {T, N}"><code>OMEinsum.tensorpermute!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensorpermute(A, perm)</code></pre><p><code>permutedims(A, perm)</code> with grouped dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/utils.jl#LL117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein!-Tuple" href="#OMEinsum.@ein!-Tuple"><code>OMEinsum.@ein!</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@ein! A[i,k] := B[i,j] * C[j,k]     # A = B * C
@ein! A[i,k] += B[i,j] * C[j,k]     # A += B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>Inplace version of <code>@ein</code>. </p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c, d = rand(2,2), rand(2,2), rand(2,2), zeros(2,2);

julia&gt; cc = copy(c);

julia&gt; @ein! d[i,k] := a[i,j] * b[j,k];

julia&gt; d ≈ a * b
true

julia&gt; d ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true

julia&gt; @ein! c[i,k] += a[i,j] * b[j,k];

julia&gt; c ≈ cc + a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/interfaces.jl#LL176-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein-Tuple" href="#OMEinsum.@ein-Tuple"><code>OMEinsum.@ein</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@ein A[i,k] := B[i,j] * C[j,k]     # A = B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>You may use numbers in place of letters for dummy indices, as in <code>@tensor</code>, and need not name the output array. Thus <code>A = @ein [1,2] := B[1,ξ] * C[ξ,2]</code> is equivalent to the above. This can also be written <code>A = ein&quot;ij,jk -&gt; ik&quot;(B,C)</code> using the numpy-style string macro.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; @ein c[i,k] := a[i,j] * b[j,k];

julia&gt; c ≈ a * b
true

julia&gt; c ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/interfaces.jl#LL117-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein_str-Tuple{AbstractString}" href="#OMEinsum.@ein_str-Tuple{AbstractString}"><code>OMEinsum.@ein_str</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ein&quot;ij,jk -&gt; ik&quot;(A,B)</code></pre><p>String macro interface which understands <code>numpy.einsum</code>&#39;s notation. Translates strings into <code>StaticEinCode</code>-structs that can be called to evaluate an <code>einsum</code>. To control evaluation order, use parentheses - instead of an <code>EinCode</code>, a <code>NestedEinsum</code> is returned which evaluates the expression according to parens. The valid character ranges for index-labels are <code>a-z</code> and <code>α-ω</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c = rand(10,10), rand(10,10), rand(10,1);

julia&gt; ein&quot;ij,jk,kl -&gt; il&quot;(a,b,c) ≈ ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c) ≈ a * b * c
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/interfaces.jl#LL1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@optein_str-Tuple{AbstractString}" href="#OMEinsum.@optein_str-Tuple{AbstractString}"><code>OMEinsum.@optein_str</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optein&quot;ij,jk,kl -&gt; ik&quot;(A, B, C)</code></pre><p>String macro interface that similar to <a href="#OMEinsum.@ein_str-Tuple{AbstractString}"><code>@ein_str</code></a>, with optimized contraction order (dimensions are assumed to be uniform).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/6e7f4df08537902de9066087bd02a9cb462fb744/src/interfaces.jl#LL25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.ExactTreewidth" href="#OMEinsumContractionOrders.ExactTreewidth"><code>OMEinsumContractionOrders.ExactTreewidth</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">const ExactTreewidth{GM} = Treewidth{SafeRules{BT, MMW{3}(), MF}, GM}
ExactTreewidth(; greedy_config = GreedyMethod(nrepeat=1)) = Treewidth(; greedy_config)</code></pre><p><code>ExactTreewidth</code> is a specialization of <code>Treewidth</code> for the <code>SafeRules</code> preprocessing algorithm with the <code>BT</code> elimination algorithm. The <code>BT</code> algorithm is an exact solver for the treewidth problem that implemented in <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl"><code>TreeWidthSolver.jl</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/treewidth.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.GreedyMethod" href="#OMEinsumContractionOrders.GreedyMethod"><code>OMEinsumContractionOrders.GreedyMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GreedyMethod{MT}
GreedyMethod(; α = 0.0, temperature = 0.0, nrepeat=1)</code></pre><p>The fast but poor greedy optimizer. Input arguments are</p><pre><code class="nohighlight hljs">* `α` is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2))
* `temperature` is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).
* `nrepeat` is the number of repeatition, returns the best contraction order.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/greedy.jl#L287-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.KaHyParBipartite" href="#OMEinsumContractionOrders.KaHyParBipartite"><code>OMEinsumContractionOrders.KaHyParBipartite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KaHyParBipartite{RT,IT,GM}
KaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),
    max_group_size=40, greedy_config=GreedyMethod())</code></pre><p>Optimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>imbalances</code> is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>greedy_config</code> is a greedy optimizer.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li><li><a href="https://arxiv.org/abs/2103.03074">Simulating the Sycamore quantum supremacy circuits</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/kahypar.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.MergeGreedy" href="#OMEinsumContractionOrders.MergeGreedy"><code>OMEinsumContractionOrders.MergeGreedy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MergeGreedy &lt;: CodeSimplifier
MergeGreedy(; threshhold=-1e-12)</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the <code>threshhold</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/Core.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.MergeVectors" href="#OMEinsumContractionOrders.MergeVectors"><code>OMEinsumContractionOrders.MergeVectors</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MergeVectors &lt;: CodeSimplifier
MergeVectors()</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/Core.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.SABipartite" href="#OMEinsumContractionOrders.SABipartite"><code>OMEinsumContractionOrders.SABipartite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SABipartite{RT,BT}
SABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000
    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)</code></pre><p>Optimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>size_dict</code>, a dictionary that specifies leg dimensions,</li><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>βs</code> is a list of inverse temperature <code>1/T</code>,</li><li><code>niters</code> is the number of iteration in each temperature,</li><li><code>ntrials</code> is the number of repetition (with different random seeds),</li><li><code>sub_optimizer</code>, the optimizer for the bipartited sub graphs, one can choose <code>GreedyMethod()</code> or <code>TreeSA()</code>,</li><li><code>initializer</code>, the partition configuration initializer, one can choose <code>:random</code> or <code>:greedy</code> (slow but better).</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/sa.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.TreeSA" href="#OMEinsumContractionOrders.TreeSA"><code>OMEinsumContractionOrders.TreeSA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TreeSA{RT,IT,GM}
TreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,
    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))</code></pre><p>Optimize the einsum contraction pattern using the simulated annealing on tensor expression tree.</p><ul><li><code>sc_target</code> is the target space complexity,</li><li><code>ntrials</code>, <code>βs</code> and <code>niters</code> are annealing parameters, doing <code>ntrials</code> indepedent annealings, each has inverse tempteratures specified by <code>βs</code>, in each temperature, do <code>niters</code> updates of the tree.</li><li><code>sc_weight</code> is the relative importance factor of space complexity in the loss compared with the time complexity.</li><li><code>rw_weight</code> is the relative importance factor of memory read and write in the loss compared with the time complexity.</li><li><code>initializer</code> specifies how to determine the initial configuration, it can be <code>:greedy</code> or <code>:random</code>. If it is using <code>:greedy</code> method to generate the initial configuration, it also uses two extra arguments <code>greedy_method</code> and <code>greedy_nrepeat</code>.</li><li><code>nslices</code> is the number of sliced legs, default is 0.</li><li><code>fixed_slices</code> is a vector of sliced legs, default is <code>[]</code>.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2108.05665">Recursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/treesa.jl#L146-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.Treewidth" href="#OMEinsumContractionOrders.Treewidth"><code>OMEinsumContractionOrders.Treewidth</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Treewidth{EL &lt;: EliminationAlgorithm, GM} &lt;: CodeOptimizer
Treewidth(; alg::EL = SafeRules(BT(), MMW{3}(), MF()), greedy_config::GM = GreedyMethod(nrepeat=1))</code></pre><p>Tree width based solver. The solvers are implemented in <a href="https://algebraicjulia.github.io/CliqueTrees.jl/stable/">CliqueTrees.jl</a> and <a href="https://github.com/ArrogantGao/TreeWidthSolver.jl">TreeWidthSolver.jl</a>. They include:</p><table><tr><th style="text-align: left">Algorithm</th><th style="text-align: left">Description</th><th style="text-align: left">Time Complexity</th><th style="text-align: left">Space Complexity</th></tr><tr><td style="text-align: left"><code>BFS</code></td><td style="text-align: left">breadth-first search</td><td style="text-align: left">O(m + n)</td><td style="text-align: left">O(n)</td></tr><tr><td style="text-align: left"><code>MCS</code></td><td style="text-align: left">maximum cardinality search</td><td style="text-align: left">O(m + n)</td><td style="text-align: left">O(n)</td></tr><tr><td style="text-align: left"><code>LexBFS</code></td><td style="text-align: left">lexicographic breadth-first search</td><td style="text-align: left">O(m + n)</td><td style="text-align: left">O(m + n)</td></tr><tr><td style="text-align: left"><code>RCMMD</code></td><td style="text-align: left">reverse Cuthill-Mckee (minimum degree)</td><td style="text-align: left">O(m + n)</td><td style="text-align: left">O(m + n)</td></tr><tr><td style="text-align: left"><code>RCMGL</code></td><td style="text-align: left">reverse Cuthill-Mckee (George-Liu)</td><td style="text-align: left">O(m + n)</td><td style="text-align: left">O(m + n)</td></tr><tr><td style="text-align: left"><code>MCSM</code></td><td style="text-align: left">maximum cardinality search (minimal)</td><td style="text-align: left">O(mn)</td><td style="text-align: left">O(n)</td></tr><tr><td style="text-align: left"><code>LexM</code></td><td style="text-align: left">lexicographic breadth-first search (minimal)</td><td style="text-align: left">O(mn)</td><td style="text-align: left">O(n)</td></tr><tr><td style="text-align: left"><code>AMF</code></td><td style="text-align: left">approximate minimum fill</td><td style="text-align: left">O(mn)</td><td style="text-align: left">O(m + n)</td></tr><tr><td style="text-align: left"><code>MF</code></td><td style="text-align: left">minimum fill</td><td style="text-align: left">O(mn²)</td><td style="text-align: left">-</td></tr><tr><td style="text-align: left"><code>MMD</code></td><td style="text-align: left">multiple minimum degree</td><td style="text-align: left">O(mn²)</td><td style="text-align: left">O(m + n)</td></tr></table><p>Detailed descriptions is available in the <a href="https://algebraicjulia.github.io/CliqueTrees.jl/stable/api/#Elimination-Algorithms">CliqueTrees.jl</a>.</p><p><strong>Fields</strong></p><ul><li><code>alg::EL</code>: The algorithm to use for the treewidth calculation. Available elimination algorithms are listed above.</li><li><code>greedy_config::GM</code>: The configuration for the greedy method.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; optimizer = Treewidth();

julia&gt; eincode = OMEinsumContractionOrders.EinCode([[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;], [&#39;b&#39;, &#39;c&#39;, &#39;e&#39;, &#39;f&#39;], [&#39;e&#39;], [&#39;d&#39;, &#39;f&#39;]], [&#39;a&#39;])
ab, acd, bcef, e, df -&gt; a

julia&gt; size_dict = Dict([c=&gt;(1&lt;&lt;i) for (i,c) in enumerate([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;])]...)
Dict{Char, Int64} with 6 entries:
  &#39;f&#39; =&gt; 64
  &#39;a&#39; =&gt; 2
  &#39;c&#39; =&gt; 8
  &#39;d&#39; =&gt; 16
  &#39;e&#39; =&gt; 32
  &#39;b&#39; =&gt; 4

julia&gt; optcode = optimize_code(eincode, size_dict, optimizer)
ab, ab -&gt; a
├─ fac, bcf -&gt; ab
│  ├─ df, acd -&gt; fac
│  │  ├─ df
│  │  └─ acd
│  └─ e, bcef -&gt; bcf
│     ├─ e
│     └─ bcef
└─ ab</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/treewidth.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}" href="#OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}"><code>OMEinsumContractionOrders.contraction_complexity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contraction_complexity(eincode, size_dict) -&gt; ContractionComplexity</code></pre><p>Returns the time, space and read-write complexity of the einsum contraction. The returned object contains 3 fields:</p><ul><li>time complexity <code>tc</code> defined as <code>log2(number of element-wise multiplications)</code>.</li><li>space complexity <code>sc</code> defined as <code>log2(size of the maximum intermediate tensor)</code>.</li><li>read-write complexity <code>rwc</code> defined as <code>log2(the number of read-write operations)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/complexity.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}" href="#OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}"><code>OMEinsumContractionOrders.flop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flop(eincode, size_dict) -&gt; Int</code></pre><p>Returns the number of iterations, which is different with the true floating point operations (FLOP) by a factor of 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/complexity.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}" href="#OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}"><code>OMEinsumContractionOrders.label_elimination_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">label_elimination_order(code) -&gt; Vector</code></pre><p>Returns a vector of labels sorted by the order they are eliminated in the contraction tree. The contraction tree is specified by <code>code</code>, which e.g. can be a <code>NestedEinsum</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/complexity.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_code" href="#OMEinsumContractionOrders.optimize_code"><code>OMEinsumContractionOrders.optimize_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true) -&gt; optimized_eincode</code></pre><p>Optimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a <code>NestedEinsum</code> instance. Input arguments are</p><ul><li><code>eincode</code> is an einsum contraction code instance, one of <code>DynamicEinCode</code>, <code>StaticEinCode</code> or <code>NestedEinsum</code>.</li><li><code>size</code> is a dictionary of &quot;edge label=&gt;edge size&quot; that contains the size information, one can use <code>uniformsize(eincode, 2)</code> to create a uniform size.</li><li><code>optimizer</code> is a <code>CodeOptimizer</code> instance, should be one of <code>GreedyMethod</code>, <code>Treewidth</code>, <code>KaHyParBipartite</code>, <code>SABipartite</code> or <code>TreeSA</code>. Check their docstrings for details.</li><li><code>simplifier</code> is one of <code>MergeVectors</code> or <code>MergeGreedy</code>.</li><li>optimize the permutation if <code>permute</code> is true.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum

julia&gt; code = ein&quot;ij, jk, kl, il-&gt;&quot;
ij, jk, kl, il -&gt; 

julia&gt; optimize_code(code, uniformsize(code, 2), TreeSA());</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/interfaces.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_greedy-Union{Tuple{T2}, Tuple{TT}, Tuple{TA}, Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict{L, T2}}} where {L, TA, TT, T2}" href="#OMEinsumContractionOrders.optimize_greedy-Union{Tuple{T2}, Tuple{TT}, Tuple{TA}, Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict{L, T2}}} where {L, TA, TT, T2}"><code>OMEinsumContractionOrders.optimize_greedy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_greedy(eincode, size_dict; α = 0.0, temperature = 0.0, nrepeat=1)</code></pre><p>Greedy optimizing the contraction order and return a <code>NestedEinsum</code> object. Check the docstring of <code>tree_greedy</code> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/greedy.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_kahypar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_kahypar(code, size_dict; sc_target, max_group_size=40, imbalances=0.0:0.01:0.2, greedy_method=MinSpaceOut(), greedy_nrepeat=1)</code></pre><p>Optimize the einsum <code>code</code> contraction order using the KaHyPar + Greedy approach. <code>size_dict</code> is a dictionary that specifies leg dimensions.  Check the docstring of <code>KaHyParBipartite</code> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/kahypar.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_kahypar_auto</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_kahypar_auto(code, size_dict; max_group_size=40, sub_optimizer = GreedyMethod())</code></pre><p>Find the optimal contraction order automatically by determining the <code>sc_target</code> with bisection. It can fail if the tree width of your graph is larger than <code>100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/kahypar.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_sa</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_sa(code, size_dict; sc_target, max_group_size=40, βs=0.1:0.2:15.0, niters=1000, ntrials=50,
       sub_optimizer = GreedyMethod(), initializer=:random)</code></pre><p>Optimize the einsum <code>code</code> contraction order using the Simulated Annealing bipartition + Greedy approach. <code>size_dict</code> is a dictionary that specifies leg dimensions.  Check the docstring of <code>SABipartite</code> for detailed explaination of other input arguments.</p><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/sa.jl#L206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}" href="#OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}"><code>OMEinsumContractionOrders.optimize_tree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_tree(code, size_dict; sc_target=20, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_method=MinSpaceOut(), fixed_slices=[])</code></pre><p>Optimize the einsum contraction pattern specified by <code>code</code>, and edge sizes specified by <code>size_dict</code>. Check the docstring of <a href="#OMEinsumContractionOrders.TreeSA"><code>TreeSA</code></a> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/treesa.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_treewidth-Union{Tuple{EL}, Tuple{GM}, Tuple{OMEinsumContractionOrders.Treewidth{EL, GM}, OMEinsumContractionOrders.AbstractEinsum, Dict}} where {GM, EL}" href="#OMEinsumContractionOrders.optimize_treewidth-Union{Tuple{EL}, Tuple{GM}, Tuple{OMEinsumContractionOrders.Treewidth{EL, GM}, OMEinsumContractionOrders.AbstractEinsum, Dict}} where {GM, EL}"><code>OMEinsumContractionOrders.optimize_treewidth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_treewidth(optimizer, eincode, size_dict)</code></pre><p>Optimizing the contraction order via solve the exact tree width of the line graph corresponding to the eincode and return a <code>NestedEinsum</code> object. Check the docstring of <code>treewidth_method</code> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/treewidth.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}" href="#OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}"><code>OMEinsumContractionOrders.peak_memory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">peak_memory(code, size_dict::Dict) -&gt; Int</code></pre><p>Estimate peak memory in number of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/complexity.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{TT}, Tuple{TA}, Tuple{OMEinsumContractionOrders.IncidenceList{Int64, ET}, Any}} where {TA, TT, ET}" href="#OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{TT}, Tuple{TA}, Tuple{OMEinsumContractionOrders.IncidenceList{Int64, ET}, Any}} where {TA, TT, ET}"><code>OMEinsumContractionOrders.tree_greedy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tree_greedy(incidence_list, log2_sizes; α = 0.0, temperature = 0.0, nrepeat=1)</code></pre><p>Compute greedy order, and the time and space complexities, the rows of the <code>incidence_list</code> are vertices and columns are edges. <code>log2_sizes</code> are defined on edges. <code>α</code> is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2)) <code>temperature</code> is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.9.9/src/greedy.jl#L16-L23">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../applications/">« Applications</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Sunday 4 May 2025 15:16">Sunday 4 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
