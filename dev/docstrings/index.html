<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DocStrings · OMEinsum.jl</title><meta name="title" content="DocStrings · OMEinsum.jl"/><meta property="og:title" content="DocStrings · OMEinsum.jl"/><meta property="twitter:title" content="DocStrings · OMEinsum.jl"/><meta name="description" content="Documentation for OMEinsum.jl."/><meta property="og:description" content="Documentation for OMEinsum.jl."/><meta property="twitter:description" content="Documentation for OMEinsum.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OMEinsum.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../parsing/">Parsing</a></li><li><a class="tocitem" href="../implementation/">Implementations</a></li><li><a class="tocitem" href="../contractionorder/">Contraction order optimization</a></li><li><a class="tocitem" href="../extending/">Extending OMEinsum</a></li><li class="is-active"><a class="tocitem" href>DocStrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DocStrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DocStrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/under-Peter/OMEinsum.jl/blob/master/docs/src/docstrings.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.DynamicEinCode" href="#OMEinsum.DynamicEinCode"><code>OMEinsum.DynamicEinCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicEinCode{LT}
DynamicEinCode(ixs, iy)</code></pre><p>Wrapper to <code>eincode</code>-specification that creates a callable object to evaluate the <code>eincode</code> <code>ixs -&gt; iy</code> where <code>ixs</code> are the index-labels of the input-tensors and <code>iy</code> are the index-labels of the output.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; OMEinsum.DynamicEinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;))(a, b) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL62-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.DynamicNestedEinsum" href="#OMEinsum.DynamicNestedEinsum"><code>OMEinsum.DynamicNestedEinsum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicNestedEinsum{LT} &lt;: NestedEinsum{LT}
DynamicNestedEinsum(args, eins)
DynamicNestedEinsum{LT}(tensorindex::Int)</code></pre><p>Einsum with contraction order, where the type parameter <code>LT</code> is the label type. It has two constructors. One takes a <code>tensorindex</code> as input, which represents the leaf node in a contraction tree. The other takes an iterable of type <code>DynamicNestedEinsum</code>, <code>args</code>, as the siblings, and <code>eins</code> to specify the contraction operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL163-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinArray" href="#OMEinsum.EinArray"><code>OMEinsum.EinArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinArray{T, N, TT, LX, LY, ICT, OCT} &lt;: AbstractArray{T, N}</code></pre><p>A struct to hold the intermediate result of an <code>einsum</code> where all index-labels of both input and output are expanded to a rank-<code>N</code>-array whose values are lazily calculated. Indices are arranged as <em>inner indices</em> (or reduced dimensions) first and <em>then outer indices</em>.</p><p>Type parameters are</p><pre><code class="nohighlight hljs">* `T`: element type,
* `N`: array dimension,
* `TT`: type of &quot;tuple of input arrays&quot;,
* `LX`: type of &quot;tuple of input indexers&quot;,
* `LX`: type of output indexer,
* `ICT`: typeof inner CartesianIndices,
* `OCT`: typeof outer CartesianIndices,</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL141-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinCode" href="#OMEinsum.EinCode"><code>OMEinsum.EinCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinCode &lt;: AbstractEinsum
EinCode(ixs, iy)</code></pre><p>Abstract type for sum-product contraction code. The constructor returns a <code>DynamicEinCode</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinIndexer" href="#OMEinsum.EinIndexer"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs,N}</code></pre><p>A structure for indexing <code>EinArray</code>s. <code>locs</code> is the index positions (among all indices). In the constructor, <code>size</code> is the size of target tensor,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{locs}, Tuple{N}} where {N, locs}" href="#OMEinsum.EinIndexer-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{locs}, Tuple{N}} where {N, locs}"><code>OMEinsum.EinIndexer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EinIndexer{locs}(size::Tuple)</code></pre><p>Constructor for <code>EinIndexer</code> for an object of size <code>size</code> where <code>locs</code> are the locations of relevant indices in a larger tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.IndexGroup" href="#OMEinsum.IndexGroup"><code>OMEinsum.IndexGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexGroup</code></pre><p>Leaf in a contractiontree, contains the indices and the number of the tensor it describes, e.g. in &quot;ij,jk -&gt; ik&quot;, indices &quot;ik&quot; belong to tensor <code>1</code>, so would be described by IndexGroup([&#39;i&#39;,&#39;k&#39;], 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.NestedEinsum" href="#OMEinsum.NestedEinsum"><code>OMEinsum.NestedEinsum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedEinsum{LT} &lt;: AbstractEinsum</code></pre><p>The abstract type for contraction trees. It has two subtypes, <a href="#OMEinsum.DynamicNestedEinsum"><code>DynamicNestedEinsum</code></a> and <a href="#OMEinsum.StaticNestedEinsum"><code>StaticNestedEinsum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.NestedEinsumConstructor" href="#OMEinsum.NestedEinsumConstructor"><code>OMEinsum.NestedEinsumConstructor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedEinsumConstructor</code></pre><p>describes a (potentially) nested einsum. Important fields:</p><ul><li><code>args</code>, vector of all inputs, either <code>IndexGroup</code> objects corresponding to tensors or <code>NestedEinsumConstructor</code></li><li><code>iy</code>, indices of output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.StaticEinCode" href="#OMEinsum.StaticEinCode"><code>OMEinsum.StaticEinCode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticEinCode{LT, ixs, iy}</code></pre><p>The static version of <code>DynamicEinCode</code> that matches the contraction rule at compile time. It is the default return type of <code>@ein_str</code> macro. <code>LT</code> is the label type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.StaticNestedEinsum" href="#OMEinsum.StaticNestedEinsum"><code>OMEinsum.StaticNestedEinsum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticNestedEinsum{LT,args,eins} &lt;: NestedEinsum{LT}
StaticNestedEinsum(args, eins)
StaticNestedEinsum{LT}(tensorindex::Int)</code></pre><p>Einsum with contraction order, where the type parameter <code>LT</code> is the label type, <code>args</code> is a tuple of StaticNestedEinsum, <code>eins</code> is a <code>StaticEinCode</code> and leaf node is defined by setting <code>eins</code> to an integer. It has two constructors. One takes a <code>tensorindex</code> as input, which represents the leaf node in a contraction tree. The other takes an iterable of type <code>DynamicNestedEinsum</code>, <code>args</code>, as the siblings, and <code>eins</code> to specify the contraction operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL191-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{EinArray{T}, Any}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{EinArray{T}, Any}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A::EinArray, inds...)</code></pre><p>return the lazily calculated entry of <code>A</code> at index <code>inds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.allow_loops-Tuple{Bool}" href="#OMEinsum.allow_loops-Tuple{Bool}"><code>OMEinsum.allow_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allow_loops(flag::Bool)</code></pre><p>Setting this to <code>false</code> will cause OMEinsum to log an error if it falls back to <code>loop_einsum</code> evaluation, instead of calling specialised kernels. The default is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/loop_einsum.jl#LL65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.allunique-Tuple{Any}" href="#OMEinsum.allunique-Tuple{Any}"><code>OMEinsum.allunique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allunique(ix::Tuple)</code></pre><p>return true if all elements of <code>ix</code> appear only once in <code>ix</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: allunique

julia&gt; allunique((1,2,3,4))
true

julia&gt; allunique((1,2,3,1))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/utils.jl#LL87-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T" href="#OMEinsum.analyze_binary-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}, Dict{T, Int64}}} where T"><code>OMEinsum.analyze_binary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the expected labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsum.jl#LL130-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.asarray-Tuple{Any}" href="#OMEinsum.asarray-Tuple{Any}"><code>OMEinsum.asarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asarray(x[, parent::AbstractArray]) -&gt; AbstactArray</code></pre><p>Return a 0-dimensional array with item <code>x</code>, otherwise, do nothing. If a <code>parent</code> is supplied, it will try to match the parent array type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/utils.jl#LL39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{Val{ixs}, Val{iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:Tuple{Vararg{AbstractArray, NI}}}" href="#OMEinsum.einarray-Union{Tuple{TT}, Tuple{NI}, Tuple{iy}, Tuple{ixs}, Tuple{Val{ixs}, Val{iy}, TT, Any}} where {ixs, iy, NI, TT&lt;:Tuple{Vararg{AbstractArray, NI}}}"><code>OMEinsum.einarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einarray(::Val{ixs}, Val{iy}, xs, size_dict) -&gt; EinArray</code></pre><p>Constructor of <code>EinArray</code> from an <code>EinCode</code>, a tuple of tensors <code>xs</code> and a <code>size_dict</code> that assigns each index-label a size. The returned <code>EinArray</code> holds an intermediate result of the <code>einsum</code> specified by the <code>EinCode</code> with indices corresponding to all unique labels in the einsum. Reduction over the (lazily calculated) dimensions that correspond to labels not present in the output lead to the result of the einsum.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a, b));

julia&gt; ea = OMEinsum.einarray(Val(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;))),Val((&#39;i&#39;,&#39;k&#39;)), (a,b), sd);

julia&gt; dropdims(sum(ea, dims=1), dims=1) ≈ a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL171-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einsum" href="#OMEinsum.einsum"><code>OMEinsum.einsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">einsum(code::EinCode, xs, size_dict)
einsum(rule, ixs, iy, xs, size_dict)</code></pre><p>return the tensor that results from contracting the tensors <code>xs</code> according to their indices <code>ixs</code> (<code>getixs(code)</code>), where all indices that do not appear in the output <code>iy</code> (<code>getiy(code)</code>) are summed over. The result is permuted according to <code>out</code>.</p><ul><li><p><code>ixs</code> - tuple of tuples of index-labels of the input-tensors <code>xs</code></p></li><li><p><code>iy</code> - tuple of index-labels of the output-tensor</p></li><li><p><code>xs</code> - tuple of tensors</p></li><li><p><code>size_dict</code> - a dictionary that maps index-labels to their sizes</p></li></ul><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;i&#39;,&#39;k&#39;)), (a, b)) ≈ a * b
true

julia&gt; einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)),(&#39;k&#39;,&#39;i&#39;)), (a, b)) ≈ permutedims(a * b, (2,1))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsum.jl#LL2-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.einsum_grad-NTuple{6, Any}" href="#OMEinsum.einsum_grad-NTuple{6, Any}"><code>OMEinsum.einsum_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">einsum_grad(ixs, xs, iy, size_dict, cdy, i)</code></pre><p>return the gradient of the result of evaluating the <code>EinCode</code> w.r.t the <code>i</code>th tensor in <code>xs</code>. <code>cdy</code> is the result of applying the <code>EinCode</code> to the <code>xs</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: einsum_grad, get_size_dict

julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; c = einsum(EinCode(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (&#39;i&#39;,&#39;k&#39;)), (a,b));

julia&gt; sd = get_size_dict(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b));

julia&gt; einsum_grad(((&#39;i&#39;,&#39;j&#39;),(&#39;j&#39;,&#39;k&#39;)), (a,b), (&#39;i&#39;,&#39;k&#39;), sd, c, 1) ≈ c * transpose(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/autodiff.jl#LL3-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.filliys!-Tuple{Any}" href="#OMEinsum.filliys!-Tuple{Any}"><code>OMEinsum.filliys!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filliys!(neinsum::NestedEinsumConstructor)</code></pre><p>goes through all <code>NestedEinsumConstructor</code> objects in the tree and saves the correct <code>iy</code> in them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.get_size_dict!-Union{Tuple{LT}, Tuple{Any, Any, Dict{LT}}} where LT" href="#OMEinsum.get_size_dict!-Union{Tuple{LT}, Tuple{Any, Any, Dict{LT}}} where LT"><code>OMEinsum.get_size_dict!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_size_dict!(ixs, xs, size_info)</code></pre><p>return a dictionary that is used to get the size of an index-label in the einsum-specification with input-indices <code>ixs</code> and tensors <code>xs</code> after consistency within <code>ixs</code> and between <code>ixs</code> and <code>xs</code> has been verified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/interfaces.jl#LL50-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.getixsv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT" href="#OMEinsum.getixsv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT"><code>OMEinsum.getixsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getixsv(code)</code></pre><p>Get labels of input tensors for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector of vectors.</p><pre><code class="language-julia-repl hljs">julia&gt; getixsv(ein&quot;(ij,jk),k-&gt;i&quot;)
3-element Vector{Vector{Char}}:
 [&#39;i&#39;, &#39;j&#39;]
 [&#39;j&#39;, &#39;k&#39;]
 [&#39;k&#39;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL33-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.getiyv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT" href="#OMEinsum.getiyv-Union{Tuple{StaticEinCode{LT}}, Tuple{LT}} where LT"><code>OMEinsum.getiyv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getiy(code)</code></pre><p>Get labels of the output tensor for <code>EinCode</code>, <code>NestedEinsum</code> and some other einsum like objects. Returns a vector.</p><pre><code class="language-julia-repl hljs">julia&gt; getiyv(ein&quot;(ij,jk),k-&gt;i&quot;)
1-element Vector{Char}:
 &#39;i&#39;: ASCII/Unicode U+0069 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.indices_and_locs-Tuple{Any, Any}" href="#OMEinsum.indices_and_locs-Tuple{Any, Any}"><code>OMEinsum.indices_and_locs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indices_and_locs(ixs,iy)</code></pre><p>given the index-labels of input and output of an <code>einsum</code>, return (in the same order):</p><ul><li>a tuple of the distinct index-labels of the output <code>iy</code></li><li>a tuple of the distinct index-labels in <code>ixs</code> of the input not appearing in the output <code>iy</code></li><li>a tuple of tuples of locations of an index-label in the <code>ixs</code> in a list of all index-labels</li><li>a tuple of locations of index-labels in <code>iy</code> in a list of all index-labels</li></ul><p>where the list of all index-labels is simply the first  and the second output catenated and the second output catenated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL239-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.loop_einsum!-Union{Tuple{T}, Tuple{L}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{AbstractArray, N}}, AbstractArray{T, L}, Any, Any, Any}} where {N, L, T}" href="#OMEinsum.loop_einsum!-Union{Tuple{T}, Tuple{L}, Tuple{N}, Tuple{Any, Any, Tuple{Vararg{AbstractArray, N}}, AbstractArray{T, L}, Any, Any, Any}} where {N, L, T}"><code>OMEinsum.loop_einsum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_einsum!(ixs, iy, xs, y, sx, sy, size_dict)</code></pre><p>inplace-version of <code>loop_einsum</code>, saving the result in a preallocated tensor of correct size <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/loop_einsum.jl#LL15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.loop_einsum-Union{Tuple{N}, Tuple{EinCode, Tuple{Vararg{AbstractArray, N}}, Any}} where N" href="#OMEinsum.loop_einsum-Union{Tuple{N}, Tuple{EinCode, Tuple{Vararg{AbstractArray, N}}, Any}} where N"><code>OMEinsum.loop_einsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loop_einsum(::EinCode, xs, size_dict)</code></pre><p>evaluates the eincode specified by <code>EinCode</code> and the tensors <code>xs</code> by looping over all possible indices and calculating the contributions ot the result. Scales exponentially in the number of distinct index-labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/loop_einsum.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, Tuple{Vararg{Any, N}}}} where N" href="#OMEinsum.map_prod-Union{Tuple{N}, Tuple{Tuple, Any, Tuple{Vararg{Any, N}}}} where N"><code>OMEinsum.map_prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_prod(xs, ind, indexers)</code></pre><p>calculate the value of an <code>EinArray</code> with <code>EinIndexer</code>s <code>indexers</code> at location <code>ind</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/Core.jl#LL229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.match_rule-Tuple{Any, Any}" href="#OMEinsum.match_rule-Tuple{Any, Any}"><code>OMEinsum.match_rule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match_rule(ixs, iy)
match_rule(code::EinCode)</code></pre><p>Returns the rule that matches, otherwise use <code>DefaultRule</code> - the slow <code>loop_einsum</code> backend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/matchrule.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.nopermute-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}" href="#OMEinsum.nopermute-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}"><code>OMEinsum.nopermute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nopermute(ix,iy)</code></pre><p>check that all values in <code>iy</code> that are also in <code>ix</code> have the same relative order,</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using OMEinsum: nopermute

julia&gt; nopermute((1,2,3),(1,2))
true

julia&gt; nopermute((1,2,3),(2,1))
false</code></pre><p>e.g. <code>nopermute((1,2,3),(1,2))</code> is true while <code>nopermute((1,2,3),(2,1))</code> is false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/utils.jl#LL58-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}" href="#OMEinsum.parse_parens-Tuple{AbstractString, Any, Any}"><code>OMEinsum.parse_parens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_parens(s::AbstractString, i, narg)</code></pre><p>parse one level of parens starting at index <code>i</code> where <code>narg</code> counts which tensor the current group of indices, e.g. &quot;ijk&quot;, belongs to. Recursively calls itself for each new opening paren that&#39;s opened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/einsequence.jl#LL19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.tensorpermute!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Any, Any, Any}} where {T, N}" href="#OMEinsum.tensorpermute!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{T, N}, Any, Any, Any}} where {T, N}"><code>OMEinsum.tensorpermute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tensorpermute(A, perm)</code></pre><p><code>permutedims(A, perm)</code> with grouped dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/utils.jl#LL117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein!-Tuple" href="#OMEinsum.@ein!-Tuple"><code>OMEinsum.@ein!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ein! A[i,k] := B[i,j] * C[j,k]     # A = B * C
@ein! A[i,k] += B[i,j] * C[j,k]     # A += B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>Inplace version of <code>@ein</code>. </p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c, d = rand(2,2), rand(2,2), rand(2,2), zeros(2,2);

julia&gt; cc = copy(c);

julia&gt; @ein! d[i,k] := a[i,j] * b[j,k];

julia&gt; d ≈ a * b
true

julia&gt; d ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true

julia&gt; @ein! c[i,k] += a[i,j] * b[j,k];

julia&gt; c ≈ cc + a * b
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/interfaces.jl#LL166-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein-Tuple" href="#OMEinsum.@ein-Tuple"><code>OMEinsum.@ein</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ein A[i,k] := B[i,j] * C[j,k]     # A = B * C</code></pre><p>Macro interface similar to that of other packages.</p><p>You may use numbers in place of letters for dummy indices, as in <code>@tensor</code>, and need not name the output array. Thus <code>A = @ein [1,2] := B[1,ξ] * C[ξ,2]</code> is equivalent to the above. This can also be written <code>A = ein&quot;ij,jk -&gt; ik&quot;(B,C)</code> using the numpy-style string macro.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b = rand(2,2), rand(2,2);

julia&gt; @ein c[i,k] := a[i,j] * b[j,k];

julia&gt; c ≈ a * b
true

julia&gt; c ≈ ein&quot;ij,jk -&gt; ik&quot;(a,b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/interfaces.jl#LL107-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsum.@ein_str-Tuple{AbstractString}" href="#OMEinsum.@ein_str-Tuple{AbstractString}"><code>OMEinsum.@ein_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">ein&quot;ij,jk -&gt; ik&quot;(A,B)</code></pre><p>String macro interface which understands <code>numpy.einsum</code>&#39;s notation. Translates strings into <code>StaticEinCode</code>-structs that can be called to evaluate an <code>einsum</code>. To control evaluation order, use parentheses - instead of an <code>EinCode</code>, a <code>NestedEinsum</code> is returned which evaluates the expression according to parens. The valid character ranges for index-labels are <code>a-z</code> and <code>α-ω</code>.</p><p><strong>example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c = rand(10,10), rand(10,10), rand(10,1);

julia&gt; ein&quot;ij,jk,kl -&gt; il&quot;(a,b,c) ≈ ein&quot;(ij,jk),kl -&gt; il&quot;(a,b,c) ≈ a * b * c
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/under-Peter/OMEinsum.jl/blob/8cd4a523687ec4a4822c75bbc182c5eb536ea927/src/interfaces.jl#LL1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.GreedyMethod" href="#OMEinsumContractionOrders.GreedyMethod"><code>OMEinsumContractionOrders.GreedyMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GreedyMethod{MT}
GreedyMethod(; method=MinSpaceOut(), nrepeat=10)</code></pre><p>The fast but poor greedy optimizer. Input arguments are</p><ul><li><code>method</code> is <code>MinSpaceDiff()</code> or <code>MinSpaceOut</code>.<ul><li><code>MinSpaceOut</code> choose one of the contraction that produces a minimum output tensor size,</li><li><code>MinSpaceDiff</code> choose one of the contraction that decrease the space most.</li></ul></li><li><code>nrepeat</code> is the number of repeatition, returns the best contraction order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/greedy.jl#L295-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.KaHyParBipartite" href="#OMEinsumContractionOrders.KaHyParBipartite"><code>OMEinsumContractionOrders.KaHyParBipartite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KaHyParBipartite{RT,IT,GM}
KaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),
    max_group_size=40, greedy_config=GreedyMethod())</code></pre><p>Optimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>imbalances</code> is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>greedy_config</code> is a greedy optimizer.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li><li><a href="https://arxiv.org/abs/2103.03074">Simulating the Sycamore quantum supremacy circuits</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/kahypar.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.MergeGreedy" href="#OMEinsumContractionOrders.MergeGreedy"><code>OMEinsumContractionOrders.MergeGreedy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MergeGreedy &lt;: CodeSimplifier
MergeGreedy(; threshhold=-1e-12)</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the <code>threshhold</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/Core.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.MergeVectors" href="#OMEinsumContractionOrders.MergeVectors"><code>OMEinsumContractionOrders.MergeVectors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MergeVectors &lt;: CodeSimplifier
MergeVectors()</code></pre><p>Contraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/Core.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.SABipartite" href="#OMEinsumContractionOrders.SABipartite"><code>OMEinsumContractionOrders.SABipartite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SABipartite{RT,BT}
SABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000
    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)</code></pre><p>Optimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by <code>max_group_size</code> and maximum space complexity specified by <code>sc_target</code>, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are</p><ul><li><code>size_dict</code>, a dictionary that specifies leg dimensions,</li><li><code>sc_target</code> is the target space complexity, defined as <code>log2(number of elements in the largest tensor)</code>,</li><li><code>max_group_size</code> is the maximum size that allowed to used greedy search,</li><li><code>βs</code> is a list of inverse temperature <code>1/T</code>,</li><li><code>niters</code> is the number of iteration in each temperature,</li><li><code>ntrials</code> is the number of repetition (with different random seeds),</li><li><code>greedy_config</code> configures the greedy method,</li><li><code>initializer</code>, the partition configuration initializer, one can choose <code>:random</code> or <code>:greedy</code> (slow but better).</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/sa.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.TreeSA" href="#OMEinsumContractionOrders.TreeSA"><code>OMEinsumContractionOrders.TreeSA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeSA{RT,IT,GM}
TreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,
    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))</code></pre><p>Optimize the einsum contraction pattern using the simulated annealing on tensor expression tree.</p><ul><li><code>sc_target</code> is the target space complexity,</li><li><code>ntrials</code>, <code>βs</code> and <code>niters</code> are annealing parameters, doing <code>ntrials</code> indepedent annealings, each has inverse tempteratures specified by <code>βs</code>, in each temperature, do <code>niters</code> updates of the tree.</li><li><code>sc_weight</code> is the relative importance factor of space complexity in the loss compared with the time complexity.</li><li><code>rw_weight</code> is the relative importance factor of memory read and write in the loss compared with the time complexity.</li><li><code>initializer</code> specifies how to determine the initial configuration, it can be <code>:greedy</code> or <code>:random</code>. If it is using <code>:greedy</code> method to generate the initial configuration, it also uses two extra arguments <code>greedy_method</code> and <code>greedy_nrepeat</code>.</li><li><code>nslices</code> is the number of sliced legs, default is 0.</li><li><code>fixed_slices</code> is a vector of sliced legs, default is <code>[]</code>.</li></ul><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2108.05665">Recursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/treesa.jl#L146-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}" href="#OMEinsumContractionOrders.contraction_complexity-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}"><code>OMEinsumContractionOrders.contraction_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contraction_complexity(eincode, size_dict) -&gt; ContractionComplexity</code></pre><p>Returns the time, space and read-write complexity of the einsum contraction. The returned object contains 3 fields:</p><ul><li>time complexity <code>tc</code> defined as <code>log2(number of element-wise multiplications)</code>.</li><li>space complexity <code>sc</code> defined as <code>log2(size of the maximum intermediate tensor)</code>.</li><li>read-write complexity <code>rwc</code> defined as <code>log2(the number of read-write operations)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/complexity.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}" href="#OMEinsumContractionOrders.flop-Union{Tuple{VT}, Tuple{LT}, Tuple{OMEinsumContractionOrders.EinCode, Dict{LT, VT}}} where {LT, VT}"><code>OMEinsumContractionOrders.flop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flop(eincode, size_dict) -&gt; Int</code></pre><p>Returns the number of iterations, which is different with the true floating point operations (FLOP) by a factor of 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/complexity.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}" href="#OMEinsumContractionOrders.label_elimination_order-Tuple{OMEinsumContractionOrders.NestedEinsum}"><code>OMEinsumContractionOrders.label_elimination_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">label_elimination_order(code) -&gt; Vector</code></pre><p>Returns a vector of labels sorted by the order they are eliminated in the contraction tree. The contraction tree is specified by <code>code</code>, which e.g. can be a <code>NestedEinsum</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/complexity.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_code" href="#OMEinsumContractionOrders.optimize_code"><code>OMEinsumContractionOrders.optimize_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true) -&gt; optimized_eincode</code></pre><p>Optimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a <code>NestedEinsum</code> instance. Input arguments are</p><ul><li><code>eincode</code> is an einsum contraction code instance, one of <code>DynamicEinCode</code>, <code>StaticEinCode</code> or <code>NestedEinsum</code>.</li><li><code>size</code> is a dictionary of &quot;edge label=&gt;edge size&quot; that contains the size information, one can use <code>uniformsize(eincode, 2)</code> to create a uniform size.</li><li><code>optimizer</code> is a <code>CodeOptimizer</code> instance, should be one of <code>GreedyMethod</code>, <code>KaHyParBipartite</code>, <code>SABipartite</code> or <code>TreeSA</code>. Check their docstrings for details.</li><li><code>simplifier</code> is one of <code>MergeVectors</code> or <code>MergeGreedy</code>.</li><li>optimize the permutation if <code>permute</code> is true.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using OMEinsum

julia&gt; code = ein&quot;ij, jk, kl, il-&gt;&quot;
ij, jk, kl, il -&gt; </code></pre><pre><code class="nohighlight hljs">julia&gt; optimize_code(code, uniformsize(code, 2), TreeSA())
SlicedEinsum{Char, NestedEinsum{DynamicEinCode{Char}}}(Char[], ki, ki -&gt; 
├─ jk, ij -&gt; ki
│  ├─ jk
│  └─ ij
└─ kl, il -&gt; ki
   ├─ kl
   └─ il
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/interfaces.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_greedy-Union{Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict}} where L" href="#OMEinsumContractionOrders.optimize_greedy-Union{Tuple{L}, Tuple{OMEinsumContractionOrders.EinCode{L}, Dict}} where L"><code>OMEinsumContractionOrders.optimize_greedy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_greedy(eincode, size_dict; method=MinSpaceOut(), nrepeat=10)</code></pre><p>Greedy optimizing the contraction order and return a <code>NestedEinsum</code> object. Methods are</p><ul><li><code>MinSpaceOut</code>, always choose the next contraction that produces the minimum output tensor.</li><li><code>MinSpaceDiff</code>, always choose the next contraction that minimizes the total space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/greedy.jl#L256-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_kahypar-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_kahypar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_kahypar(code, size_dict; sc_target, max_group_size=40, imbalances=0.0:0.01:0.2, greedy_method=MinSpaceOut(), greedy_nrepeat=10)</code></pre><p>Optimize the einsum <code>code</code> contraction order using the KaHyPar + Greedy approach. <code>size_dict</code> is a dictionary that specifies leg dimensions.  Check the docstring of <code>KaHyParBipartite</code> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/kahypar.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_kahypar_auto-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_kahypar_auto</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_kahypar_auto(code, size_dict; max_group_size=40, greedy_method=MinSpaceOut(), greedy_nrepeat=10)</code></pre><p>Find the optimal contraction order automatically by determining the <code>sc_target</code> with bisection. It can fail if the tree width of your graph is larger than <code>100</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/kahypar.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}" href="#OMEinsumContractionOrders.optimize_sa-Tuple{OMEinsumContractionOrders.EinCode, Any}"><code>OMEinsumContractionOrders.optimize_sa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_sa(code, size_dict; sc_target, max_group_size=40, βs=0.1:0.2:15.0, niters=1000, ntrials=50,
        greedy_method=MinSpaceOut(), greedy_nrepeat=10, initializer=:random)</code></pre><p>Optimize the einsum <code>code</code> contraction order using the Simulated Annealing bipartition + Greedy approach. <code>size_dict</code> is a dictionary that specifies leg dimensions.  Check the docstring of <code>SABipartite</code> for detailed explaination of other input arguments.</p><p><strong>References</strong></p><ul><li><a href="https://arxiv.org/abs/2002.01935">Hyper-optimized tensor network contraction</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/sa.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}" href="#OMEinsumContractionOrders.optimize_tree-Tuple{OMEinsumContractionOrders.AbstractEinsum, Any}"><code>OMEinsumContractionOrders.optimize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_tree(code, size_dict; sc_target=20, βs=0.1:0.1:10, ntrials=2, niters=100, sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_method=MinSpaceOut(), greedy_nrepeat=1, fixed_slices=[])</code></pre><p>Optimize the einsum contraction pattern specified by <code>code</code>, and edge sizes specified by <code>size_dict</code>. Check the docstring of <a href="#OMEinsumContractionOrders.TreeSA"><code>TreeSA</code></a> for detailed explaination of other input arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/treesa.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}" href="#OMEinsumContractionOrders.peak_memory-Tuple{OMEinsumContractionOrders.NestedEinsum, Dict}"><code>OMEinsumContractionOrders.peak_memory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">peak_memory(code, size_dict::Dict) -&gt; Int</code></pre><p>Estimate peak memory in number of elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/complexity.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{VT}, Tuple{OMEinsumContractionOrders.IncidenceList{VT, ET}, Any}} where {VT, ET}" href="#OMEinsumContractionOrders.tree_greedy-Union{Tuple{ET}, Tuple{VT}, Tuple{OMEinsumContractionOrders.IncidenceList{VT, ET}, Any}} where {VT, ET}"><code>OMEinsumContractionOrders.tree_greedy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tree_greedy(incidence_list, log2_sizes; method=MinSpaceOut())</code></pre><p>Compute greedy order, and the time and space complexities, the rows of the <code>incidence_list</code> are vertices and columns are edges. <code>log2_sizes</code> are defined on edges.</p><pre><code class="language-julia hljs">julia&gt; code = ein&quot;(abc,cde),(ce,sf,j),ak-&gt;ael&quot;
aec, ec, ak -&gt; ael
├─ ce, sf, j -&gt; ec
│  ├─ sf
│  ├─ j
│  └─ ce
├─ ak
└─ abc, cde -&gt; aec
   ├─ cde
   └─ abc


julia&gt; optimize_greedy(code, Dict([c=&gt;2 for c in &quot;abcdefjkls&quot;]))
ae, ak -&gt; ea
├─ ak
└─ aec, ec -&gt; ae
   ├─ ce,  -&gt; ce
   │  ├─ sf, j -&gt; 
   │  │  ├─ j
   │  │  └─ sf
   │  └─ ce
   └─ abc, cde -&gt; aec
      ├─ cde
      └─ abc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl/blob/v0.8.3/src/greedy.jl#L18-L50">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../extending/">« Extending OMEinsum</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 9 April 2024 01:56">Tuesday 9 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
